"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var React = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _getTransitionTimeMs = _interopRequireDefault(require("./getTransitionTimeMs"));

var SmoothCollapse =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2["default"])(SmoothCollapse, _React$Component);

  function SmoothCollapse(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, SmoothCollapse);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(SmoothCollapse).call(this, props));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_removeTransitionEndListener", function () {});
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_main", React.createRef());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_inner", React.createRef());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onNextTransitionEnd", function (el, callback) {
      _this._removeTransitionEndListener();

      var listener = function listener() {
        _this._removeTransitionEndListener();

        callback();
      };

      var timeout;

      _this._removeTransitionEndListener = function () {
        _this._removeTransitionEndListener = function () {};

        clearTimeout(timeout);
        el.removeEventListener('transitionend', listener);
      }; // Wait until the transitionend event, or until a timer goes off in
      // case the event doesn't fire because the browser doesn't support it
      // or the element is hidden before it happens. The timer is a little
      // longer than the transition is supposed to take to make sure we don't
      // cut the animation early while it's still going if the browser is
      // running it just a little slow.


      el.addEventListener('transitionend', listener);
      var ms = (0, _getTransitionTimeMs["default"])(_this.props.heightTransition) * 1.1 + 500;
      timeout = setTimeout(listener, ms);
    });
    _this.state = {
      renderInner: props.expanded || SmoothCollapse._visibleWhenClosed(props),
      closing: false,
      fullyClosed: !props.expanded,
      height: props.expanded ? 'auto' : props.collapsedHeight
    };
    return _this;
  }

  (0, _createClass2["default"])(SmoothCollapse, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._removeTransitionEndListener();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this2 = this;

      if (!prevProps.expanded && this.props.expanded) {
        this._removeTransitionEndListener();

        var mainEl = this._main.current;
        var innerEl = this._inner.current;
        if (!mainEl || !innerEl) throw new Error('Should not happen'); // Set the collapser to the target height instead of auto so that it
        // animates correctly. Then switch it to 'auto' after the animation so
        // that it flows correctly if the page is resized.

        var targetHeight = "".concat(innerEl.clientHeight, "px");
        this.setState({
          height: targetHeight
        });

        this._onNextTransitionEnd(mainEl, function () {
          _this2.setState({
            height: 'auto'
          }, function () {
            if (_this2.props.onChangeEnd) {
              _this2.props.onChangeEnd();
            }
          });
        });
      } else if (prevProps.expanded && !this.props.expanded) {
        this._removeTransitionEndListener();

        if (!this._inner.current) throw new Error('Should not happen');
        this.setState({
          height: "".concat(this._inner.current.clientHeight, "px")
        }, function () {
          var mainEl = _this2._main.current;
          if (!mainEl) throw new Error('Should not happen');
          mainEl.clientHeight; // force the page layout

          _this2.setState({
            height: _this2.props.collapsedHeight,
            closing: true
          });

          _this2._onNextTransitionEnd(mainEl, function () {
            _this2.setState({
              closing: false,
              fullyClosed: true
            });

            if (_this2.props.onChangeEnd) {
              _this2.props.onChangeEnd();
            }
          });
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var visibleWhenClosed = SmoothCollapse._visibleWhenClosed(this.props);

      var _this$props = this.props,
          allowOverflowWhenOpen = _this$props.allowOverflowWhenOpen,
          children = _this$props.children,
          collapsedHeight = _this$props.collapsedHeight,
          eagerRender = _this$props.eagerRender,
          expanded = _this$props.expanded,
          heightTransition = _this$props.heightTransition,
          onChangeEnd = _this$props.onChangeEnd,
          props = (0, _objectWithoutProperties2["default"])(_this$props, ["allowOverflowWhenOpen", "children", "collapsedHeight", "eagerRender", "expanded", "heightTransition", "onChangeEnd"]);
      var _this$state = this.state,
          height = _this$state.height,
          fullyClosed = _this$state.fullyClosed,
          renderInner = _this$state.renderInner;
      var innerEl = renderInner ? React.createElement("div", {
        ref: this._inner,
        style: {
          overflow: allowOverflowWhenOpen && height === 'auto' ? 'visible' : 'hidden'
        }
      }, children) : null;
      return React.createElement("div", (0, _extends2["default"])({}, props, {
        ref: this._main,
        style: {
          height: height,
          overflow: allowOverflowWhenOpen && height === 'auto' ? 'visible' : 'hidden',
          display: fullyClosed && !visibleWhenClosed ? 'none' : null,
          transition: "height ".concat(heightTransition)
        }
      }), innerEl);
    }
  }], [{
    key: "_visibleWhenClosed",
    value: function _visibleWhenClosed(props) {
      return props.eagerRender || parseFloat(props.collapsedHeight) !== 0;
    }
  }, {
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (props.expanded && (state.closing || state.fullyClosed)) {
        return {
          closing: false,
          fullyClosed: false,
          renderInner: true
        };
      } else if (!props.expanded && (state.closing || state.fullyClosed) && state.height !== props.collapsedHeight) {
        return {
          height: props.collapsedHeight,
          renderInner: state.renderInner || SmoothCollapse._visibleWhenClosed(props)
        };
      }

      return null;
    }
  }]);
  return SmoothCollapse;
}(React.Component);

exports["default"] = SmoothCollapse;
(0, _defineProperty2["default"])(SmoothCollapse, "propTypes", {
  expanded: _propTypes["default"].bool.isRequired,
  onChangeEnd: _propTypes["default"].func,
  collapsedHeight: _propTypes["default"].string,
  heightTransition: _propTypes["default"].string,
  className: _propTypes["default"].string,
  allowOverflowWhenOpen: _propTypes["default"].bool,
  eagerRender: _propTypes["default"].bool
});
(0, _defineProperty2["default"])(SmoothCollapse, "defaultProps", {
  collapsedHeight: '0',
  heightTransition: '.25s ease',
  className: '',
  allowOverflowWhenOpen: false,
  eagerRender: false
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJTbW9vdGhDb2xsYXBzZSIsInByb3BzIiwiUmVhY3QiLCJjcmVhdGVSZWYiLCJlbCIsImNhbGxiYWNrIiwiX3JlbW92ZVRyYW5zaXRpb25FbmRMaXN0ZW5lciIsImxpc3RlbmVyIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwibXMiLCJoZWlnaHRUcmFuc2l0aW9uIiwic2V0VGltZW91dCIsInN0YXRlIiwicmVuZGVySW5uZXIiLCJleHBhbmRlZCIsIl92aXNpYmxlV2hlbkNsb3NlZCIsImNsb3NpbmciLCJmdWxseUNsb3NlZCIsImhlaWdodCIsImNvbGxhcHNlZEhlaWdodCIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsIm1haW5FbCIsIl9tYWluIiwiY3VycmVudCIsImlubmVyRWwiLCJfaW5uZXIiLCJFcnJvciIsInRhcmdldEhlaWdodCIsImNsaWVudEhlaWdodCIsInNldFN0YXRlIiwiX29uTmV4dFRyYW5zaXRpb25FbmQiLCJvbkNoYW5nZUVuZCIsInZpc2libGVXaGVuQ2xvc2VkIiwiYWxsb3dPdmVyZmxvd1doZW5PcGVuIiwiY2hpbGRyZW4iLCJlYWdlclJlbmRlciIsIm92ZXJmbG93IiwiZGlzcGxheSIsInRyYW5zaXRpb24iLCJwYXJzZUZsb2F0IiwiQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiYm9vbCIsImlzUmVxdWlyZWQiLCJmdW5jIiwic3RyaW5nIiwiY2xhc3NOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUVBOztJQW1CcUJBLGM7Ozs7O0FBcUJuQiwwQkFBWUMsS0FBWixFQUEwQjtBQUFBOztBQUFBO0FBQ3hCLDBIQUFNQSxLQUFOO0FBRHdCLHFIQXBCSyxZQUFNLENBQUUsQ0FvQmI7QUFBQSw4RkFuQmxCQyxLQUFLLENBQUNDLFNBQU4sRUFtQmtC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LFVBQUFBLFdBQVcsRUFBRTtBQUhSLFNBQVA7QUFLRCxPQU5ELE1BTU8sSUFBSSxDQUFDZixLQUFLLENBQUNnQixRQUFQLEtBQW9CRixLQUFLLENBQUNJLE9BQU4sSUFBaUJKLEtBQUssQ0FBQ0ssV0FBM0MsS0FBMkRMLEtBQUssQ0FBQ00sTUFBTixLQUFpQnBCLEtBQUssQ0FBQ3FCLGVBQXRGLEVBQXVHO0FBQzVHLGVBQU87QUFDTEQsVUFBQUEsTUFBTSxFQUFFcEIsS0FBSyxDQUFDcUIsZUFEVDtBQUVMTixVQUFBQSxXQUFXLEVBQUVELEtBQUssQ0FBQ0MsV0FBTixJQUFxQmhCLGNBQWMsQ0FBQ2tCLGtCQUFmLENBQWtDakIsS0FBbEM7QUFGN0IsU0FBUDtBQUlEOztBQUNELGFBQU8sSUFBUDtBQUNEOzs7RUFyRHlDQyxLQUFLLENBQUMwQyxTOzs7aUNBQTdCNUMsYyxlQUlBO0FBQ2pCaUIsRUFBQUEsUUFBUSxFQUFFNEIsc0JBQVVDLElBQVYsQ0FBZUMsVUFEUjtBQUVqQlosRUFBQUEsV0FBVyxFQUFFVSxzQkFBVUcsSUFGTjtBQUdqQjFCLEVBQUFBLGVBQWUsRUFBRXVCLHNCQUFVSSxNQUhWO0FBSWpCcEMsRUFBQUEsZ0JBQWdCLEVBQUVnQyxzQkFBVUksTUFKWDtBQUtqQkMsRUFBQUEsU0FBUyxFQUFFTCxzQkFBVUksTUFMSjtBQU1qQlosRUFBQUEscUJBQXFCLEVBQUVRLHNCQUFVQyxJQU5oQjtBQU9qQlAsRUFBQUEsV0FBVyxFQUFFTSxzQkFBVUM7QUFQTixDO2lDQUpBOUMsYyxrQkFhRztBQUNwQnNCLEVBQUFBLGVBQWUsRUFBRSxHQURHO0FBRXBCVCxFQUFBQSxnQkFBZ0IsRUFBRSxXQUZFO0FBR3BCcUMsRUFBQUEsU0FBUyxFQUFFLEVBSFM7QUFJcEJiLEVBQUFBLHFCQUFxQixFQUFFLEtBSkg7QUFLcEJFLEVBQUFBLFdBQVcsRUFBRTtBQUxPLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgZ2V0VHJhbnNpdGlvblRpbWVNcyBmcm9tICcuL2dldFRyYW5zaXRpb25UaW1lTXMnO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlO1xuICBleHBhbmRlZDogYm9vbGVhbjtcbiAgb25DaGFuZ2VFbmQ/OiA/KCkgPT4gdm9pZDtcbiAgY29sbGFwc2VkSGVpZ2h0OiBzdHJpbmc7XG4gIGhlaWdodFRyYW5zaXRpb246IHN0cmluZztcbiAgY2xhc3NOYW1lOiBzdHJpbmc7XG4gIGFsbG93T3ZlcmZsb3dXaGVuT3BlbjogYm9vbGVhbjtcbiAgZWFnZXJSZW5kZXI6IGJvb2xlYW47XG59O1xudHlwZSBTdGF0ZSA9IHtcbiAgcmVuZGVySW5uZXI6IGJvb2xlYW47XG4gIGNsb3Npbmc6IGJvb2xlYW47XG4gIGZ1bGx5Q2xvc2VkOiBib29sZWFuO1xuICBoZWlnaHQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNtb290aENvbGxhcHNlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLFN0YXRlPiB7XG4gIF9yZW1vdmVUcmFuc2l0aW9uRW5kTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgX21haW4gPSBSZWFjdC5jcmVhdGVSZWY8SFRNTERpdkVsZW1lbnQ+KCk7XG4gIF9pbm5lciA9IFJlYWN0LmNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBleHBhbmRlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICBvbkNoYW5nZUVuZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY29sbGFwc2VkSGVpZ2h0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGhlaWdodFRyYW5zaXRpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFsbG93T3ZlcmZsb3dXaGVuT3BlbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgZWFnZXJSZW5kZXI6IFByb3BUeXBlcy5ib29sXG4gIH07XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY29sbGFwc2VkSGVpZ2h0OiAnMCcsXG4gICAgaGVpZ2h0VHJhbnNpdGlvbjogJy4yNXMgZWFzZScsXG4gICAgY2xhc3NOYW1lOiAnJyxcbiAgICBhbGxvd092ZXJmbG93V2hlbk9wZW46IGZhbHNlLFxuICAgIGVhZ2VyUmVuZGVyOiBmYWxzZVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgcmVuZGVySW5uZXI6IHByb3BzLmV4cGFuZGVkIHx8IFNtb290aENvbGxhcHNlLl92aXNpYmxlV2hlbkNsb3NlZChwcm9wcyksXG4gICAgICBjbG9zaW5nOiBmYWxzZSxcbiAgICAgIGZ1bGx5Q2xvc2VkOiAhcHJvcHMuZXhwYW5kZWQsXG4gICAgICBoZWlnaHQ6IHByb3BzLmV4cGFuZGVkID8gJ2F1dG8nIDogcHJvcHMuY29sbGFwc2VkSGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBfdmlzaWJsZVdoZW5DbG9zZWQocHJvcHM6IFByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLmVhZ2VyUmVuZGVyIHx8IHBhcnNlRmxvYXQocHJvcHMuY29sbGFwc2VkSGVpZ2h0KSAhPT0gMDtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX3JlbW92ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcigpO1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHMsIHN0YXRlOiBTdGF0ZSkge1xuICAgIGlmIChwcm9wcy5leHBhbmRlZCAmJiAoc3RhdGUuY2xvc2luZyB8fCBzdGF0ZS5mdWxseUNsb3NlZCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3Npbmc6IGZhbHNlLFxuICAgICAgICBmdWxseUNsb3NlZDogZmFsc2UsXG4gICAgICAgIHJlbmRlcklubmVyOiB0cnVlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLmV4cGFuZGVkICYmIChzdGF0ZS5jbG9zaW5nIHx8IHN0YXRlLmZ1bGx5Q2xvc2VkKSAmJiBzdGF0ZS5oZWlnaHQgIT09IHByb3BzLmNvbGxhcHNlZEhlaWdodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBwcm9wcy5jb2xsYXBzZWRIZWlnaHQsXG4gICAgICAgIHJlbmRlcklubmVyOiBzdGF0ZS5yZW5kZXJJbm5lciB8fCBTbW9vdGhDb2xsYXBzZS5fdmlzaWJsZVdoZW5DbG9zZWQocHJvcHMpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9vbk5leHRUcmFuc2l0aW9uRW5kID0gKGVsOiBIVE1MRGl2RWxlbWVudCwgY2FsbGJhY2s6ICgpID0+IHZvaWQpID0+IHtcbiAgICB0aGlzLl9yZW1vdmVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoKTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlVHJhbnNpdGlvbkVuZExpc3RlbmVyKCk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBsZXQgdGltZW91dDtcbiAgICB0aGlzLl9yZW1vdmVUcmFuc2l0aW9uRW5kTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVUcmFuc2l0aW9uRW5kTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBsaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIC8vIFdhaXQgdW50aWwgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIG9yIHVudGlsIGEgdGltZXIgZ29lcyBvZmYgaW5cbiAgICAvLyBjYXNlIHRoZSBldmVudCBkb2Vzbid0IGZpcmUgYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgICAvLyBvciB0aGUgZWxlbWVudCBpcyBoaWRkZW4gYmVmb3JlIGl0IGhhcHBlbnMuIFRoZSB0aW1lciBpcyBhIGxpdHRsZVxuICAgIC8vIGxvbmdlciB0aGFuIHRoZSB0cmFuc2l0aW9uIGlzIHN1cHBvc2VkIHRvIHRha2UgdG8gbWFrZSBzdXJlIHdlIGRvbid0XG4gICAgLy8gY3V0IHRoZSBhbmltYXRpb24gZWFybHkgd2hpbGUgaXQncyBzdGlsbCBnb2luZyBpZiB0aGUgYnJvd3NlciBpc1xuICAgIC8vIHJ1bm5pbmcgaXQganVzdCBhIGxpdHRsZSBzbG93LlxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBsaXN0ZW5lcik7XG4gICAgY29uc3QgbXMgPSBnZXRUcmFuc2l0aW9uVGltZU1zKHRoaXMucHJvcHMuaGVpZ2h0VHJhbnNpdGlvbikgKiAxLjEgKyA1MDA7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGlzdGVuZXIsIG1zKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzLCBwcmV2U3RhdGU6IFN0YXRlKSB7XG4gICAgaWYgKCFwcmV2UHJvcHMuZXhwYW5kZWQgJiYgdGhpcy5wcm9wcy5leHBhbmRlZCkge1xuICAgICAgdGhpcy5fcmVtb3ZlVHJhbnNpdGlvbkVuZExpc3RlbmVyKCk7XG5cbiAgICAgIGNvbnN0IG1haW5FbCA9IHRoaXMuX21haW4uY3VycmVudDtcbiAgICAgIGNvbnN0IGlubmVyRWwgPSB0aGlzLl9pbm5lci5jdXJyZW50O1xuICAgICAgaWYgKCFtYWluRWwgfHwgIWlubmVyRWwpIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBoYXBwZW4nKTtcblxuICAgICAgLy8gU2V0IHRoZSBjb2xsYXBzZXIgdG8gdGhlIHRhcmdldCBoZWlnaHQgaW5zdGVhZCBvZiBhdXRvIHNvIHRoYXQgaXRcbiAgICAgIC8vIGFuaW1hdGVzIGNvcnJlY3RseS4gVGhlbiBzd2l0Y2ggaXQgdG8gJ2F1dG8nIGFmdGVyIHRoZSBhbmltYXRpb24gc29cbiAgICAgIC8vIHRoYXQgaXQgZmxvd3MgY29ycmVjdGx5IGlmIHRoZSBwYWdlIGlzIHJlc2l6ZWQuXG4gICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSBgJHtpbm5lckVsLmNsaWVudEhlaWdodH1weGA7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaGVpZ2h0OiB0YXJnZXRIZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9vbk5leHRUcmFuc2l0aW9uRW5kKG1haW5FbCwgKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBoZWlnaHQ6ICdhdXRvJ1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2VFbmQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2VFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwcmV2UHJvcHMuZXhwYW5kZWQgJiYgIXRoaXMucHJvcHMuZXhwYW5kZWQpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcigpO1xuXG4gICAgICBpZiAoIXRoaXMuX2lubmVyLmN1cnJlbnQpIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBoYXBwZW4nKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBoZWlnaHQ6IGAke3RoaXMuX2lubmVyLmN1cnJlbnQuY2xpZW50SGVpZ2h0fXB4YFxuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICBjb25zdCBtYWluRWwgPSB0aGlzLl9tYWluLmN1cnJlbnQ7XG4gICAgICAgIGlmICghbWFpbkVsKSB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgaGFwcGVuJyk7XG5cbiAgICAgICAgbWFpbkVsLmNsaWVudEhlaWdodDsgLy8gZm9yY2UgdGhlIHBhZ2UgbGF5b3V0XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGhlaWdodDogdGhpcy5wcm9wcy5jb2xsYXBzZWRIZWlnaHQsXG4gICAgICAgICAgY2xvc2luZzogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9vbk5leHRUcmFuc2l0aW9uRW5kKG1haW5FbCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY2xvc2luZzogZmFsc2UsXG4gICAgICAgICAgICBmdWxseUNsb3NlZDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlRW5kKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB2aXNpYmxlV2hlbkNsb3NlZCA9IFNtb290aENvbGxhcHNlLl92aXNpYmxlV2hlbkNsb3NlZCh0aGlzLnByb3BzKTtcbiAgICBjb25zdCB7XG4gICAgICBhbGxvd092ZXJmbG93V2hlbk9wZW4sIGNoaWxkcmVuLCBjb2xsYXBzZWRIZWlnaHQsIGVhZ2VyUmVuZGVyLCBleHBhbmRlZCxcbiAgICAgIGhlaWdodFRyYW5zaXRpb24sIG9uQ2hhbmdlRW5kLCAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtoZWlnaHQsIGZ1bGx5Q2xvc2VkLCByZW5kZXJJbm5lcn0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGlubmVyRWwgPSByZW5kZXJJbm5lciA/XG4gICAgICA8ZGl2IHJlZj17dGhpcy5faW5uZXJ9IHN0eWxlPXt7XG4gICAgICAgIG92ZXJmbG93OiBhbGxvd092ZXJmbG93V2hlbk9wZW4gJiYgaGVpZ2h0ID09PSAnYXV0bycgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1xuICAgICAgfX0+XG4gICAgICAgIHsgY2hpbGRyZW4gfVxuICAgICAgPC9kaXY+XG4gICAgICA6IG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgIHJlZj17dGhpcy5fbWFpbn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgb3ZlcmZsb3c6IGFsbG93T3ZlcmZsb3dXaGVuT3BlbiAmJiBoZWlnaHQgPT09ICdhdXRvJyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgIGRpc3BsYXk6IChmdWxseUNsb3NlZCAmJiAhdmlzaWJsZVdoZW5DbG9zZWQpID8gJ25vbmUnOiBudWxsLFxuICAgICAgICAgIHRyYW5zaXRpb246IGBoZWlnaHQgJHtoZWlnaHRUcmFuc2l0aW9ufWBcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge2lubmVyRWx9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iXX0=