{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('core-js/fn/array/find'), require('core-js/fn/object/assign'), require('clone'), require('d3-ease'), require('d3-hierarchy'), require('prop-types'), require('react')) : typeof define === 'function' && define.amd ? define(['core-js/fn/array/find', 'core-js/fn/object/assign', 'clone', 'd3-ease', 'd3-hierarchy', 'prop-types', 'react'], factory) : (global = global || self, global.ReactTreeGraph = factory(null, null, global.clone, global.d3, global.d3, global.PropTypes, global.React));\n})(this, function (find, assign, clone, d3Ease, d3Hierarchy, PropTypes, React) {\n  'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(source).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function');\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === 'object' || typeof call === 'function')) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]') return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError('Invalid attempt to spread non-iterable instance');\n  }\n\n  var regex = /on[A-Z]/;\n\n  function wrapper(func, args) {\n    return function (event) {\n      return func.apply(void 0, [event].concat(_toConsumableArray(args)));\n    };\n  } // Wraps any event handlers passed in as props with a function that passes additional arguments\n\n\n  function wrapHandlers(props) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var handlers = Object.keys(props).filter(function (propName) {\n      return regex.test(propName) && typeof props[propName] === 'function';\n    });\n    var wrappedHandlers = handlers.reduce(function (acc, handler) {\n      acc[handler] = wrapper(props[handler], args);\n      return acc;\n    }, {});\n    return _objectSpread2({}, props, {}, wrappedHandlers);\n  }\n\n  var propTypes = {\n    source: PropTypes.object.isRequired,\n    target: PropTypes.object.isRequired,\n    keyProp: PropTypes.string.isRequired,\n    x1: PropTypes.number.isRequired,\n    x2: PropTypes.number.isRequired,\n    y1: PropTypes.number.isRequired,\n    y2: PropTypes.number.isRequired,\n    pathProps: PropTypes.object.isRequired\n  };\n\n  function diagonal(x1, y1, x2, y2) {\n    return 'M'.concat(y1, ',').concat(x1, 'C').concat((y1 + y2) / 2, ',').concat(x1, ' ').concat((y1 + y2) / 2, ',').concat(x2, ' ').concat(y2, ',').concat(x2);\n  }\n\n  var Link =\n  /*#__PURE__*/\n  function (_React$PureComponent) {\n    _inherits(Link, _React$PureComponent);\n\n    function Link() {\n      _classCallCheck(this, Link);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Link).apply(this, arguments));\n    }\n\n    _createClass(Link, [{\n      key: 'render',\n      value: function render() {\n        var wrappedProps = wrapHandlers(this.props.pathProps, this.props.source.data[this.props.keyProp], this.props.target.data[this.props.keyProp]);\n        var d = diagonal(this.props.x1, this.props.y1, this.props.x2, this.props.y2);\n        return React.createElement('path', _extends({}, wrappedProps, {\n          d: d\n        }));\n      }\n    }]);\n\n    return Link;\n  }(React.PureComponent);\n\n  Link.propTypes = propTypes;\n  var propTypes$1 = {\n    x: PropTypes.number.isRequired,\n    y: PropTypes.number.isRequired,\n    keyProp: PropTypes.string.isRequired,\n    labelProp: PropTypes.string.isRequired,\n    offset: PropTypes.number.isRequired,\n    radius: PropTypes.number.isRequired,\n    circleProps: PropTypes.object.isRequired,\n    gProps: PropTypes.object.isRequired,\n    textProps: PropTypes.object.isRequired\n  };\n\n  var Node =\n  /*#__PURE__*/\n  function (_React$PureComponent) {\n    _inherits(Node, _React$PureComponent);\n\n    function Node() {\n      _classCallCheck(this, Node);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Node).apply(this, arguments));\n    }\n\n    _createClass(Node, [{\n      key: 'getTransform',\n      value: function getTransform() {\n        return 'translate('.concat(this.props.y, ', ').concat(this.props.x, ')');\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var wrappedCircleProps = wrapHandlers(this.props.circleProps, this.props[this.props.keyProp]);\n        var wrappedGProps = wrapHandlers(this.props.gProps, this.props[this.props.keyProp]);\n        var wrappedTextProps = wrapHandlers(this.props.textProps, this.props[this.props.keyProp]);\n        return React.createElement('g', _extends({}, wrappedGProps, {\n          transform: this.getTransform()\n        }), React.createElement('circle', _extends({}, wrappedCircleProps, {\n          r: this.props.radius\n        })), React.createElement('text', _extends({}, wrappedTextProps, {\n          dx: this.props.radius + 0.5,\n          dy: this.props.offset\n        }), this.props[this.props.labelProp]));\n      }\n    }]);\n\n    return Node;\n  }(React.PureComponent);\n\n  Node.propTypes = propTypes$1;\n  var propTypes$2 = {\n    children: PropTypes.node,\n    height: PropTypes.number.isRequired,\n    keyProp: PropTypes.string.isRequired,\n    labelProp: PropTypes.string.isRequired,\n    links: PropTypes.array.isRequired,\n    nodes: PropTypes.array.isRequired,\n    nodeClassName: PropTypes.string,\n    nodeOffset: PropTypes.number.isRequired,\n    nodeRadius: PropTypes.number.isRequired,\n    width: PropTypes.number.isRequired,\n    circleProps: PropTypes.object.isRequired,\n    gProps: PropTypes.object.isRequired,\n    pathProps: PropTypes.object.isRequired,\n    svgProps: PropTypes.object.isRequired,\n    textProps: PropTypes.object.isRequired\n  };\n\n  var Container =\n  /*#__PURE__*/\n  function (_React$PureComponent) {\n    _inherits(Container, _React$PureComponent);\n\n    function Container() {\n      _classCallCheck(this, Container);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Container).apply(this, arguments));\n    }\n\n    _createClass(Container, [{\n      key: 'render',\n      value: function render() {\n        var _this = this;\n\n        return React.createElement('svg', _extends({}, this.props.svgProps, {\n          height: this.props.height,\n          width: this.props.width\n        }), this.props.children, this.props.links.map(function (link) {\n          return React.createElement(Link, {\n            key: link.target.data[_this.props.keyProp],\n            keyProp: _this.props.keyProp,\n            source: link.source,\n            target: link.target,\n            x1: link.source.x,\n            x2: link.target.x,\n            y1: link.source.y,\n            y2: link.target.y,\n            pathProps: _objectSpread2({}, _this.props.pathProps, {}, link.target.data.pathProps)\n          });\n        }), this.props.nodes.map(function (node) {\n          return React.createElement(Node, _extends({\n            key: node.data[_this.props.keyProp],\n            keyProp: _this.props.keyProp,\n            labelProp: _this.props.labelProp,\n            offset: _this.props.nodeOffset,\n            radius: _this.props.nodeRadius,\n            x: node.x,\n            y: node.y,\n            circleProps: _objectSpread2({}, _this.props.circleProps, {}, node.data.circleProps),\n            gProps: _objectSpread2({}, _this.props.gProps, {}, node.data.gProps),\n            textProps: _objectSpread2({}, _this.props.textProps, {}, node.data.textProps)\n          }, node.data));\n        }));\n      }\n    }]);\n\n    return Container;\n  }(React.PureComponent);\n\n  Container.propTypes = propTypes$2;\n  var propTypes$3 = {\n    animated: PropTypes.bool.isRequired,\n    getChildren: PropTypes.func.isRequired,\n    keyProp: PropTypes.string.isRequired,\n    links: PropTypes.array.isRequired,\n    nodes: PropTypes.array.isRequired,\n    duration: PropTypes.number.isRequired,\n    easing: PropTypes.func.isRequired,\n    steps: PropTypes.number.isRequired\n  };\n\n  var Animated =\n  /*#__PURE__*/\n  function (_React$PureComponent) {\n    _inherits(Animated, _React$PureComponent);\n\n    function Animated(props) {\n      var _this;\n\n      _classCallCheck(this, Animated);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Animated).call(this, props));\n\n      if (props.animated) {\n        // If we are animating, we set the initial positions of the nodes and links to be the position of the root node\n        // and animate from there\n        var initialX = props.nodes[0].x;\n        var initialY = props.nodes[0].y;\n        _this.state = {\n          nodes: props.nodes.map(function (n) {\n            return _objectSpread2({}, n, {\n              x: initialX,\n              y: initialY\n            });\n          }),\n          links: props.links.map(function (l) {\n            return {\n              source: _objectSpread2({}, l.source, {\n                x: initialX,\n                y: initialY\n              }),\n              target: _objectSpread2({}, l.target, {\n                x: initialX,\n                y: initialY\n              })\n            };\n          })\n        };\n      } else {\n        _this.state = {\n          nodes: props.nodes,\n          links: props.links\n        };\n      }\n\n      return _this;\n    }\n\n    _createClass(Animated, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (this.props.animated) {\n          this.animate(this.props);\n        }\n      }\n    }, {\n      key: 'componentWillReceiveProps',\n      value: function componentWillReceiveProps(nextProps) {\n        if (nextProps.nodes === this.props.nodes && nextProps.links === this.props.links) {\n          return;\n        }\n\n        if (!nextProps.animated) {\n          this.setState({\n            nodes: nextProps.nodes,\n            links: nextProps.links\n          });\n          return;\n        }\n\n        this.animate(nextProps);\n      }\n    }, {\n      key: 'animate',\n      value: function animate(props) {\n        var _this2 = this; // Stop previous animation if one is already in progress.  We will start the next animation\n        // from the position we are currently in\n\n\n        clearInterval(this.animation);\n        var counter = 0; // Do as much one-time calculation outside of the animation step, which needs to be fast\n\n        var animationContext = this.getAnimationContext(this.state, props);\n        this.animation = setInterval(function () {\n          counter++;\n\n          if (counter === props.steps) {\n            clearInterval(_this2.animation);\n            _this2.animation = null;\n\n            _this2.setState({\n              nodes: props.nodes,\n              links: props.links\n            });\n\n            return;\n          }\n\n          _this2.setState(_this2.calculateNewState(animationContext, counter / props.steps));\n        }, props.duration / props.steps);\n      }\n    }, {\n      key: 'getAnimationContext',\n      value: function getAnimationContext(initialState, newState) {\n        var _this3 = this; // Nodes/links that are in both states need to be moved from the old position to the new one\n        // Nodes/links only in the initial state are being removed, and should be moved to the position\n        // of the closest ancestor that still exists, or the new root\n        // Nodes/links only in the new state are being added, and should be moved from the position of\n        // the closest ancestor that previously existed, or the old root\n        // The base determines which node/link the data (like classes and labels) comes from for rendering\n        // We only run this once at the start of the animation, so optimization is less important\n\n\n        var addedNodes = newState.nodes.filter(function (n1) {\n          return initialState.nodes.every(function (n2) {\n            return !_this3.areNodesSame(n1, n2);\n          });\n        }).map(function (n1) {\n          return {\n            base: n1,\n            old: _this3.getClosestAncestor(n1, newState, initialState),\n            new: n1\n          };\n        });\n        var changedNodes = newState.nodes.filter(function (n1) {\n          return initialState.nodes.some(function (n2) {\n            return _this3.areNodesSame(n1, n2);\n          });\n        }).map(function (n1) {\n          return {\n            base: n1,\n            old: initialState.nodes.find(function (n2) {\n              return _this3.areNodesSame(n1, n2);\n            }),\n            new: n1\n          };\n        });\n        var removedNodes = initialState.nodes.filter(function (n1) {\n          return newState.nodes.every(function (n2) {\n            return !_this3.areNodesSame(n1, n2);\n          });\n        }).map(function (n1) {\n          return {\n            base: n1,\n            old: n1,\n            new: _this3.getClosestAncestor(n1, initialState, newState)\n          };\n        });\n        var addedLinks = newState.links.filter(function (l1) {\n          return initialState.links.every(function (l2) {\n            return !_this3.areLinksSame(l1, l2);\n          });\n        }).map(function (l1) {\n          return {\n            base: l1,\n            old: _this3.getClosestAncestor(l1.target, newState, initialState),\n            new: l1\n          };\n        });\n        var changedLinks = newState.links.filter(function (l1) {\n          return initialState.links.some(function (l2) {\n            return _this3.areLinksSame(l1, l2);\n          });\n        }).map(function (l1) {\n          return {\n            base: l1,\n            old: initialState.links.find(function (l2) {\n              return _this3.areLinksSame(l1, l2);\n            }),\n            new: l1\n          };\n        });\n        var removedLinks = initialState.links.filter(function (l1) {\n          return newState.links.every(function (l2) {\n            return !_this3.areLinksSame(l1, l2);\n          });\n        }).map(function (l1) {\n          return {\n            base: l1,\n            old: l1,\n            new: _this3.getClosestAncestor(l1.target, initialState, newState)\n          };\n        });\n        return {\n          nodes: changedNodes.concat(addedNodes).concat(removedNodes),\n          links: changedLinks.concat(addedLinks).concat(removedLinks)\n        };\n      }\n    }, {\n      key: 'getClosestAncestor',\n      value: function getClosestAncestor(node, stateWithNode, stateWithoutNode) {\n        var _this4 = this;\n\n        var oldParent = node;\n\n        while (oldParent) {\n          var newParent = stateWithoutNode.nodes.find(function (n) {\n            return _this4.areNodesSame(oldParent, n);\n          });\n\n          if (newParent) {\n            return newParent;\n          }\n\n          oldParent = stateWithNode.nodes.find(function (n) {\n            return (_this4.props.getChildren(n) || []).some(function (c) {\n              return _this4.areNodesSame(oldParent, c);\n            });\n          });\n        }\n\n        return stateWithoutNode.nodes[0];\n      }\n    }, {\n      key: 'areNodesSame',\n      value: function areNodesSame(a, b) {\n        return a.data[this.props.keyProp] === b.data[this.props.keyProp];\n      }\n    }, {\n      key: 'areLinksSame',\n      value: function areLinksSame(a, b) {\n        return a.source.data[this.props.keyProp] === b.source.data[this.props.keyProp] && a.target.data[this.props.keyProp] === b.target.data[this.props.keyProp];\n      }\n    }, {\n      key: 'calculateNewState',\n      value: function calculateNewState(animationContext, interval) {\n        var _this5 = this;\n\n        return {\n          nodes: animationContext.nodes.map(function (n) {\n            return _this5.calculateNodePosition(n.base, n.old, n['new'], interval);\n          }),\n          links: animationContext.links.map(function (l) {\n            return _this5.calculateLinkPosition(l.base, l.old, l['new'], interval);\n          })\n        };\n      }\n    }, {\n      key: 'calculateNodePosition',\n      value: function calculateNodePosition(node, start, end, interval) {\n        return _objectSpread2({}, node, {\n          x: this.calculateNewValue(start.x, end.x, interval),\n          y: this.calculateNewValue(start.y, end.y, interval)\n        });\n      }\n    }, {\n      key: 'calculateLinkPosition',\n      value: function calculateLinkPosition(link, start, end, interval) {\n        return {\n          source: _objectSpread2({}, link.source, {\n            x: this.calculateNewValue(start.source ? start.source.x : start.x, end.source ? end.source.x : end.x, interval),\n            y: this.calculateNewValue(start.source ? start.source.y : start.y, end.source ? end.source.y : end.y, interval)\n          }),\n          target: _objectSpread2({}, link.target, {\n            x: this.calculateNewValue(start.target ? start.target.x : start.x, end.target ? end.target.x : end.x, interval),\n            y: this.calculateNewValue(start.target ? start.target.y : start.y, end.target ? end.target.y : end.y, interval)\n          })\n        };\n      }\n    }, {\n      key: 'calculateNewValue',\n      value: function calculateNewValue(start, end, interval) {\n        return start + (end - start) * this.props.easing(interval);\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        return React.createElement(Container, _extends({}, this.props, this.state));\n      }\n    }]);\n\n    return Animated;\n  }(React.PureComponent);\n\n  Animated.propTypes = propTypes$3;\n  var propTypes$4 = {\n    data: PropTypes.object.isRequired,\n    animated: PropTypes.bool.isRequired,\n    children: PropTypes.node,\n    duration: PropTypes.number.isRequired,\n    easing: PropTypes.func.isRequired,\n    steps: PropTypes.number.isRequired,\n    height: PropTypes.number.isRequired,\n    width: PropTypes.number.isRequired,\n    keyProp: PropTypes.string.isRequired,\n    labelProp: PropTypes.string.isRequired,\n    getChildren: PropTypes.func.isRequired,\n    margins: PropTypes.shape({\n      bottom: PropTypes.number.isRequired,\n      left: PropTypes.number.isRequired,\n      right: PropTypes.number.isRequired,\n      top: PropTypes.number.isRequired\n    }).isRequired,\n    nodeOffset: PropTypes.number.isRequired,\n    nodeRadius: PropTypes.number.isRequired,\n    circleProps: PropTypes.object.isRequired,\n    gProps: PropTypes.object.isRequired,\n    pathProps: PropTypes.object.isRequired,\n    svgProps: PropTypes.object.isRequired,\n    textProps: PropTypes.object.isRequired\n  };\n  var defaultProps = {\n    animated: false,\n    duration: 500,\n    easing: d3Ease.easeQuadOut,\n    getChildren: function getChildren(n) {\n      return n.children;\n    },\n    steps: 20,\n    keyProp: 'name',\n    labelProp: 'name',\n    margins: {\n      bottom: 10,\n      left: 20,\n      right: 150,\n      top: 10\n    },\n    nodeOffset: 3.5,\n    nodeRadius: 5,\n    circleProps: {},\n    gProps: {},\n    pathProps: {},\n    svgProps: {},\n    textProps: {}\n  };\n\n  var Tree =\n  /*#__PURE__*/\n  function (_React$PureComponent) {\n    _inherits(Tree, _React$PureComponent);\n\n    function Tree() {\n      _classCallCheck(this, Tree);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Tree).apply(this, arguments));\n    }\n\n    _createClass(Tree, [{\n      key: 'render',\n      value: function render() {\n        var _this = this;\n\n        var contentWidth = this.props.width - this.props.margins.left - this.props.margins.right;\n        var contentHeight = this.props.height - this.props.margins.top - this.props.margins.bottom; // data is cloned because d3 will mutate the object passed in\n\n        var data = d3Hierarchy.hierarchy(clone(this.props.data), this.props.getChildren);\n        var root = d3Hierarchy.tree().size([contentHeight, contentWidth])(data);\n        var nodes = root.descendants();\n        var links = root.links();\n        nodes.forEach(function (node) {\n          node.y += _this.props.margins.top;\n        });\n        return React.createElement(Animated, {\n          animated: this.props.animated,\n          duration: this.props.duration,\n          easing: this.props.easing,\n          getChildren: this.props.getChildren,\n          height: this.props.height,\n          keyProp: this.props.keyProp,\n          labelProp: this.props.labelProp,\n          links: links,\n          nodes: nodes,\n          nodeOffset: this.props.nodeOffset,\n          nodeRadius: this.props.nodeRadius,\n          steps: this.props.steps,\n          width: this.props.width,\n          circleProps: this.props.circleProps,\n          gProps: _objectSpread2({\n            className: 'node'\n          }, this.props.gProps),\n          pathProps: _objectSpread2({\n            className: 'link'\n          }, this.props.pathProps),\n          svgProps: this.props.svgProps,\n          textProps: this.props.textProps\n        }, this.props.children);\n      }\n    }]);\n\n    return Tree;\n  }(React.PureComponent);\n\n  Tree.propTypes = propTypes$4;\n  Tree.defaultProps = defaultProps;\n  return Tree;\n});","map":null,"metadata":{},"sourceType":"script"}