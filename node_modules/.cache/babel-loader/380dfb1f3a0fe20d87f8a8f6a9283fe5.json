{"ast":null,"code":"// Generated by CoffeeScript 1.6.3\n(function () {\n  var Base,\n      events,\n      _ref,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n\n  events = require('events');\n  /*\n  Base class used by Notifier and Monitor.\n  It provides a basic framework to manage states.\n  Implementers must implement\n  @states ( a hashmap of states to handlers )\n  @public_api ( with handlers )\n  \n  It also implements a subset of the EventEmitter API\n  on, off and emit\n  */\n\n  module.exports = Base = function (_super) {\n    __extends(Base, _super);\n\n    function Base() {\n      _ref = Base.__super__.constructor.apply(this, arguments);\n      return _ref;\n    }\n\n    Base.prototype.state = 'ready';\n\n    Base.prototype.transition = function (state, f) {\n      var handler;\n\n      if (!(state in this.states)) {\n        throw new Error('Invalid Transition ' + (\"\" + this.state + \" -> \" + state));\n      }\n\n      if (this.state === 'ready') {\n        if (typeof f === \"function\") {\n          f();\n        }\n\n        this.state = state;\n\n        if (typeof (handler = this.states[state]) === 'string') {\n          return typeof this[handler] === \"function\" ? this[handler]() : void 0;\n        }\n      }\n    };\n    /*\n    __listeners: null\n    _l: -> @__listeners ?= {}\n    emit: ( event, e ) ->\n      if ( ls = @_l()[event] )?\n        x(e) for x in ls\n    on: ( event, listener ) ->\n      arr = ( @_l()[event] ?= [] )\n      arr.push listener unless listener in arr\n      undefined\n    off: ( event, listener ) ->\n      l = @_l()\n      if ( arr = l[event] )?\n        l[event] = ( x for x in arr when not ( x is listener or x is listener.L ) )\n      undefined\n    once: ( event, listener ) ->\n      l = (e) => @off event, l ; listener e\n      l.L = listener\n      @on event, l\n    */\n\n\n    return Base;\n  }(events.EventEmitter);\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}