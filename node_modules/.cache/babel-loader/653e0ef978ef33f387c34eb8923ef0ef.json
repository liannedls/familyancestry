{"ast":null,"code":"import { prop, withId, withType, flat, inAscOrder, min, max } from '../utils';\nexport default (families => {\n  const connectors = [];\n  families.filter(withType('root', 'child')).forEach(family => {\n    if (family.pUnits.length !== 1) {\n      throw new Error(`[relatives-tree]: a child family should have only one parent's unit`);\n    }\n\n    const mY = family.top + 2;\n    const pUnit = family.pUnits[0];\n    const pX = family.left + pUnit.shift + pUnit.size;\n    const pY = family.top + 1;\n    connectors.push({\n      points: [pX, pY, pX, mY]\n    });\n    const parentIds = family.pUnits.map(prop('ids')).reduce(flat);\n    const cXs = [];\n    family.cUnits.forEach(cUnit => {\n      const cX = family.left + cUnit.shift + 1;\n      cUnit.nodes.forEach((node, index) => {\n        if (node.parents.find(rel => parentIds.indexOf(rel.id) !== -1)) {\n          const nX = cX + index * 2;\n          cXs.push(nX);\n          connectors.push({\n            points: [nX, mY, nX, mY + 1]\n          });\n        }\n      });\n\n      if (cUnit.size === 2) {\n        connectors.push({\n          points: [cX, mY + 1, cX + 2, mY + 1]\n        });\n      } else if (cUnit.size === 1 && cUnit.nodes[0].spouses.length) {\n        family.cUnits.forEach(nUnit => {\n          if (nUnit.nodes.findIndex(withId(cUnit.nodes[0].spouses[0].id)) !== -1) {\n            const xX = [cX, family.left + nUnit.shift + 1].sort(inAscOrder);\n            connectors.push({\n              points: [xX[0], mY + 1, xX[1], mY + 1]\n            });\n          }\n        });\n      }\n    });\n\n    if (cXs.length > 1) {\n      connectors.push({\n        points: [min(cXs), mY, max(cXs), mY]\n      });\n    } else if (cXs.length === 1 && pX !== cXs[0]) {\n      connectors.push({\n        points: [Math.min(pX, cXs[0]), mY, Math.max(pX, cXs[0]), mY]\n      });\n    }\n  });\n  return connectors;\n});","map":{"version":3,"sources":["../../src/connectors/children.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { prop, withId, withType, flat, inAscOrder, min, max } from '../utils';\nexport default (families) => {\n    const connectors = [];\n    families.filter(withType('root', 'child')).forEach(family => {\n        if (family.pUnits.length !== 1) {\n            throw new Error(`[relatives-tree]: a child family should have only one parent's unit`);\n        }\n        const mY = family.top + 2;\n        const pUnit = family.pUnits[0];\n        const pX = family.left + pUnit.shift + (pUnit.size);\n        const pY = family.top + 1;\n        connectors.push({\n            points: [pX, pY, pX, mY],\n        });\n        const parentIds = family.pUnits\n            .map(prop('ids'))\n            .reduce(flat);\n        const cXs = [];\n        family.cUnits.forEach(cUnit => {\n            const cX = family.left + cUnit.shift + 1;\n            cUnit.nodes.forEach((node, index) => {\n                if (node.parents.find(rel => parentIds.indexOf(rel.id) !== -1)) {\n                    const nX = cX + (index * 2);\n                    cXs.push(nX);\n                    connectors.push({\n                        points: [nX, mY, nX, mY + 1],\n                    });\n                }\n            });\n            if (cUnit.size === 2) {\n                connectors.push({\n                    points: [cX, mY + 1, cX + 2, mY + 1],\n                });\n            }\n            else if (cUnit.size === 1 && cUnit.nodes[0].spouses.length) {\n                family.cUnits.forEach(nUnit => {\n                    if (nUnit.nodes.findIndex(withId(cUnit.nodes[0].spouses[0].id)) !== -1) {\n                        const xX = [cX, family.left + nUnit.shift + 1].sort(inAscOrder);\n                        connectors.push({\n                            points: [xX[0], mY + 1, xX[1], mY + 1],\n                        });\n                    }\n                });\n            }\n        });\n        if (cXs.length > 1) {\n            connectors.push({\n                points: [min(cXs), mY, max(cXs), mY],\n            });\n        }\n        else if (cXs.length === 1 && pX !== cXs[0]) {\n            connectors.push({\n                points: [Math.min(pX, cXs[0]), mY, Math.max(pX, cXs[0]), mY],\n            });\n        }\n    });\n    return connectors;\n};\n//# sourceMappingURL=children.js.map"]},"metadata":{},"sourceType":"module"}