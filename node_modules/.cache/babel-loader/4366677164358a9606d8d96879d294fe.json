{"ast":null,"code":"const d3ize = tree => {\n  const notes = tree.filter(hasTag('NOTE'));\n  let surnameList = [];\n  const peopleNodes = tree.filter(hasTag('INDI')).map(p => toNode(p, notes, surnameList));\n  const families = tree.filter(hasTag('FAM'));\n  const links = families.reduce((memo, family) => {\n    return memo.concat(familyLinks(family, peopleNodes));\n  }, []);\n  assignFy(peopleNodes, links);\n  return {\n    nodes: peopleNodes,\n    links: links,\n    families: families,\n    surnameList: surnameList\n  };\n}; // Tag search function\n\n\nconst hasTag = val => {\n  return node => {\n    return node.tag === val;\n  };\n}; // Data search function\n\n\nconst hasData = val => {\n  return node => {\n    return node.data === val;\n  };\n}; // ID search function\n\n\nconst hasID = val => {\n  return node => {\n    return node.id === val;\n  };\n};\n\nconst assignFy = (peopleNodes, links) => {\n  // YOB known\n  let yesyob = peopleNodes.filter(p => {\n    return p.yob !== '?' && !isNaN(+p.yob);\n  });\n  yesyob.forEach(p => p.fy = +p.yob); // YOB unknown\n\n  let noyob = peopleNodes.filter(p => {\n    return p.yob === '?';\n  });\n  let count = 10; // Cycle through list, adding fy until all complete\n\n  while (noyob.length > 0 && count > 0) {\n    let tempnoyob = noyob.slice();\n    tempnoyob.forEach((p, index) => {\n      // Build array of family\n      let tpFamily = [];\n      links.forEach(link => {\n        if (link.source == p.id) {\n          tpFamily.push({\n            pRole: 'source',\n            pType: link.sourceType,\n            other: link.target,\n            oType: link.targetType\n          });\n        } else if (link.target == p.id) {\n          tpFamily.push({\n            pRole: 'target',\n            pType: link.targetType,\n            other: link.source,\n            oType: link.sourceType\n          });\n        }\n\n        ;\n      }); // Check family for YOB\n\n      tpFamily.forEach(member => {\n        // USE SOME() INSTEAD OF FOREACH!!!\n        peopleNodes.forEach(person => {\n          // USE SOME() INSTEAD OF FOREACH!!!\n          if (person.id == member.other && person.fy !== undefined) {\n            // Person is source\n            if (member.pRole === 'source') {\n              // Person is husband\n              if (member.pType === 'HUSB' && member.oType === 'WIFE') {\n                p.fy = +person.fy - 3; // Person is father\n              } else if (member.pType === 'HUSB' && member.oType === 'CHIL') {\n                p.fy = +person.fy - 30; // Person is mother\n              } else if (member.pType === 'WIFE') {\n                p.fy = +person.fy - 27;\n              } // Person is target\n\n            } else if (member.pRole === 'target') {\n              // Person is wife\n              if (member.pType === 'WIFE' && member.oType === 'HUSB') {\n                p.fy = +person.fy + 3; // Person is child of father\n              } else if (member.pType === 'CHIL' && member.oType === 'HUSB') {\n                p.fy = +person.fy + 30; // Person is child of mother\n              } else if (member.pType === 'CHIL' && member.oType === 'WIFE') {\n                p.fy = +person.fy + 27;\n              }\n            }\n          }\n        });\n      });\n\n      if (p.fy !== undefined) {\n        noyob.splice(index, index + 1);\n      }\n    });\n    count -= 1;\n  }\n\n  const convertFy = peopleNodes => {\n    const fyRatio = peopleNodes => {\n      if (peopleNodes.length <= 50) {\n        return 3;\n      } else if (peopleNodes.length > 50 && peopleNodes.length <= 150) {\n        return 4;\n      } else if (peopleNodes.length > 150 && peopleNodes.length <= 250) {\n        return 5;\n      } else if (peopleNodes.length > 250) {\n        return 6;\n      }\n    };\n\n    let allFy = [];\n    peopleNodes.forEach(p => {\n      if (p.fy !== undefined) {\n        p.fy = p.fy * fyRatio(peopleNodes);\n        allFy.push(p.fy);\n      }\n    });\n    let total = 0;\n    allFy.forEach(fy => total += fy);\n    let average = total / allFy.length;\n    peopleNodes.forEach(p => {\n      if (p.fy !== undefined) {\n        p.fy = -(p.fy - average);\n      }\n    });\n  };\n\n  convertFy(peopleNodes);\n}; // Get title\n\n\nconst getTitle = p => {\n  const title = p.tree.filter(hasTag('TITL')) || [];\n\n  if (title.length > 0) {\n    return title[title.length - 1].data;\n  }\n}; // Get full name\n\n\nconst getName = p => {\n  let nameNode = (p.tree.filter(hasTag('NAME')) || [])[0];\n\n  if (nameNode) {\n    return nameNode.data.replace(/\\//g, '');\n  } else {\n    return '?';\n  }\n}; // Get first name\n\n\nconst getFirstName = p => {\n  // Find 'NAME' tag\n  const nameNode = (p.tree.filter(hasTag('NAME')) || [])[0];\n\n  if (nameNode) {\n    // Find 'GIVN' tag\n    let firstNameNode = (nameNode.tree.filter(hasTag('GIVN')) || [])[0];\n\n    if (firstNameNode) {\n      // Remove middle name\n      if (firstNameNode.data.search(' ') !== -1) {\n        return firstNameNode.data.slice(0, firstNameNode.data.search(' '));\n      } else {\n        return firstNameNode.data;\n      }\n    } else {\n      return '?';\n    }\n  } else {\n    return '?';\n  }\n}; // Get surname\n\n\nconst getSurname = p => {\n  // Find 'NAME' tag\n  const nameNode = (p.tree.filter(hasTag('NAME')) || [])[0];\n\n  if (nameNode) {\n    // Find 'SURN' tag\n    const surnameNode = (nameNode.tree.filter(hasTag('SURN')) || [])[0]; // If surname listed\n\n    if (surnameNode) {\n      // Remove alternate surnames\n      if (surnameNode.data.search(',') !== -1) {\n        return surnameNode.data.slice(0, surnameNode.data.search(','));\n      } else {\n        return surnameNode.data;\n      } // Derive surname from name\n\n    } else {\n      nameArr = nameNode.data.split(' '); // Look for forward slashes\n\n      let isSlashes = nameArr.some(str => str[0] === \"/\");\n\n      if (isSlashes) {\n        return nameArr.find(str => str[0] === \"/\").replace(/\\//g, ''); // no slashes, use final item in array\n      } else {\n        nameArr[nameArr.length - 1] = nameArr[nameArr.length - 1].replace(/\\//g, '');\n        return nameArr.length > 1 ? nameArr[nameArr.length - 1] : \"Hrm\";\n      }\n    }\n  } else {\n    return '?';\n  }\n}; // Get gender\n\n\nconst getGender = p => {\n  // Find 'SEX' tag\n  let genderNode = (p.tree.filter(hasTag('SEX')) || [])[0];\n\n  if (genderNode) {\n    return genderNode.data;\n  } else {\n    return 'Unknown';\n  }\n}; // Get date of birth\n\n\nconst getDOB = p => {\n  // Find 'BIRT' tag\n  let dobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n\n  if (dobNode) {\n    // Find 'DATE' tag\n    let dateNode = (dobNode.tree.filter(hasTag('DATE')) || [])[0];\n\n    if (dateNode) {\n      return dateNode.data;\n    } else {\n      return '?';\n    }\n  } else {\n    return '?';\n  }\n}; // Get year of birth\n\n\nconst getYOB = p => {\n  // Find 'BIRT' tag\n  let dobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n\n  if (dobNode) {\n    // Find 'DATE' tag\n    let dateNode = (dobNode.tree.filter(hasTag('DATE')) || [])[0];\n\n    if (dateNode) {\n      return dateNode.data.slice(-4);\n    } else {\n      return '?';\n    }\n  } else {\n    return '?';\n  }\n}; // Get place of birth\n\n\nconst getPOB = p => {\n  // Find 'BIRT' tag\n  let pobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n\n  if (pobNode) {\n    // Find 'DATE' tag\n    let placeNode = (pobNode.tree.filter(hasTag('PLAC')) || [])[0];\n\n    if (placeNode) {\n      return placeNode.data;\n    } else {\n      return '';\n    }\n  } else {\n    return '';\n  }\n}; // Get date of death\n\n\nconst getDOD = p => {\n  // Find 'DEAT' tag\n  let dobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n  let dodNode = (p.tree.filter(hasTag('DEAT')) || [])[0];\n\n  if (dodNode) {\n    // Find 'DATE' tag\n    let dateNode = (dodNode.tree.filter(hasTag('DATE')) || [])[0];\n\n    if (dateNode) {\n      return dateNode.data;\n    } else {\n      return '?';\n    }\n  } else if (dobNode) {\n    let dateNode = (dobNode.tree.filter(hasTag('DATE')) || [])[0];\n\n    if (dateNode) {\n      return dateNode.data.slice(-4) + 100;\n    } else {\n      return '?';\n    }\n  } else {\n    return 'Present';\n  }\n}; // Get year of death\n\n\nconst getYOD = p => {\n  let thisYear = new Date().getFullYear(); // Find 'DEAT' tag\n\n  let dobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n  let dodNode = (p.tree.filter(hasTag('DEAT')) || [])[0]; // If DEATH tag\n\n  if (dodNode) {\n    // Find 'DATE' tag\n    let dateNode = (dodNode.tree.filter(hasTag('DATE')) || [])[0]; // If death date listed\n\n    if (dateNode) {\n      return dateNode.data.slice(-4);\n    } else {\n      return '?';\n    } // BIRT tag, but no DEAT tag\n\n  } else if (dobNode && !dodNode) {\n    let dateNode = (dobNode.tree.filter(hasTag('DATE')) || [])[0]; // If DOB listed\n\n    if (dateNode) {\n      // If born > 100 yrs ago, call dead\n      if (dateNode.data.slice(-4) < thisYear - 100) {\n        return '?';\n      } else {\n        return 'Present';\n      }\n    } else {\n      return '?';\n    } // no DEAT or BIRT tag\n\n  } else {\n    return '?';\n  }\n}; // Get place of birth\n\n\nconst getPOD = p => {\n  // Find 'BIRT' tag\n  let podNode = (p.tree.filter(hasTag('DEAT')) || [])[0];\n\n  if (podNode) {\n    // Find 'DATE' tag\n    let placeNode = (podNode.tree.filter(hasTag('PLAC')) || [])[0];\n\n    if (placeNode) {\n      return placeNode.data;\n    } else {\n      return '';\n    }\n  } else {\n    return '';\n  }\n}; // Get relatives\n\n\nconst getFamilies = p => {\n  let families = [];\n  let pediInfo; // If child\n\n  let familyNode1 = p.tree.filter(hasTag('FAMC')) || [];\n\n  if (familyNode1) {\n    for (let i = 0; i < familyNode1.length; i++) {\n      if (familyNode1[i].tree.length > 0) {\n        // Get pedigree info\n        if (familyNode1[i].tree[0].tag == 'PEDI') {\n          pediInfo = {\n            frel: familyNode1[i].tree[0].data,\n            mrel: familyNode1[i].tree[0].data\n          };\n        } else if (familyNode1[i].tree[0].tag == '_FREL') {\n          pediInfo = {\n            frel: familyNode1[i].tree[0].data,\n            mrel: familyNode1[i].tree[1].data\n          };\n        }\n      }\n\n      families.push({\n        id: familyNode1[i].data,\n        pedi: pediInfo\n      });\n    }\n  }\n\n  let familyNode2 = p.tree.filter(hasTag('FAMS')) || [];\n\n  if (familyNode2) {\n    for (let i = 0; i < familyNode2.length; i++) {\n      families.push({\n        id: familyNode2[i].data\n      });\n    }\n  }\n\n  return families;\n}; // Get color\n\n\nconst getColor = (p, surnameList) => {\n  const colorList = ['#ff7f50', // coral\n  '#00b4ff', // sky blue\n  '#fac641', // mexican egg yolk\n  '#8a9b0f', // olive\n  '#a7dbd8', // sea foam\n  '#a37e58', // light brown\n  '#ec4913', // burnt orange\n  '#a27dbd', // soft royal purple\n  '#11644d', // forest\n  '#b3347c', // magenta\n  '#359668', // grass & sage\n  '#fab8b4', // soft pink\n  '#6de627', // neon green\n  '#ecd078', // tangerine\n  '#bfcff7', // ligt purple blue\n  '#e08e79', // blush\n  '#c44d58', // rouge\n  '#c4ffeb', // light sea foam\n  '#a6b890', // olive sage\n  '#aaaaaa', // light blue grey\n  '#ffd3b5', // peach\n  '#826942', // chocolate\n  '#d4ee5e', // lime\n  '#ecfc85', // light yellow\n  '#666666', // off white\n  '#ffa1c3', // newborn pink\n  '#6541a3', // royal purple\n  '#75616b', // dry wine\n  '#71cfde', // baby foam\n  '#e0e0e0' // light grey\n  ]; // If color description listed in GEDCOM\n\n  const dscr = (p.tree.filter(hasTag('DSCR')) || [])[0];\n  const foundName = surnameList.find(sName => sName.surname === p.surname); // If surname already in list\n\n  if (foundName) {\n    foundName.count = foundName.count + 1;\n  } else {\n    surnameList.push({\n      surname: p.surname,\n      count: 1,\n      color: colorList[surnameList.length % colorList.length]\n    });\n  } // surnameList.color = surnameList.length % colorList.length});\n  // If color listed assign that\n\n\n  if (dscr) {\n    return dscr.data; // else assign color from colorList\n  } else {\n    return surnameList.find(sName => sName.surname === p.surname).color;\n  }\n}; // Get person notes\n\n\nconst getNotes = p => {\n  return p.tree.filter(hasTag('NOTE'));\n}; // Get Bio\n\n\nconst getBio = (p, notes) => {\n  if (p.notes.length != 0) {\n    let bio = ''; // Notes for person\n\n    p.notes.forEach(personNote => {\n      // personNote.data points to NOTE object\n      if (notes.length > 0) {\n        notes.forEach(note => {\n          if (personNote.data === note.pointer) {\n            bio += note.data; // Concat broken up note\n\n            if (note.tree.length > 0) {\n              note.tree.forEach(fragment => bio += fragment.data);\n            }\n          }\n        }); // personNote.data is actual note\n      } else {\n        bio += personNote.data;\n      }\n    });\n    return bio;\n  }\n};\n\nconst getFy = p => {\n  if (p.yob === '?') {\n    return 0;\n  } else {\n    return +(-p.yob * 3 + 6000);\n  }\n};\n\nconst toNode = (p, notes, surnameList) => {\n  p.id = p.pointer;\n  p.title = getTitle(p);\n  p.name = getName(p);\n  p.firstName = getFirstName(p);\n  p.surname = getSurname(p);\n  p.gender = getGender(p);\n  p.dob = getDOB(p);\n  p.yob = getYOB(p);\n  p.pob = getPOB(p);\n  p.dod = getDOD(p);\n  p.yod = getYOD(p);\n  p.pod = getPOD(p);\n  p.families = getFamilies(p);\n  p.color = getColor(p, surnameList);\n  p.notes = getNotes(p);\n  p.bio = getBio(p, notes);\n  return p;\n};\n\nconst familyLinks = (family, peopleNodes) => {\n  let memberLinks = [];\n  let maritalStatus = null;\n  let pedigree; // Filter only individual objects from family tree\n\n  let memberSet = family.tree.filter(function (member) {\n    return member.data && (member.data[1] === 'I' || member.data[1] === 'P');\n  }); // Filter marital status events\n\n  family.tree.filter(event => {\n    if (event.tag === 'DIV' || event.tag === 'MARR') {\n      if (maritalStatus !== 'DIV') {\n        maritalStatus = event.tag;\n      }\n    }\n  }); // Iterate over each member of set to connect with other members\n\n  while (memberSet.length > 1) {\n    for (let i = 1; i < memberSet.length; i++) {\n      // Exclude sibling relationships\n      if (memberSet[0].tag != 'CHIL') {\n        // If marital status listed\n        if (memberSet[0].tag == 'HUSB' && memberSet[i].tag == 'WIFE') {\n          memberLinks.push({\n            \"source\": memberSet[0].data,\n            \"target\": memberSet[i].data,\n            \"sourceType\": memberSet[0].tag,\n            \"targetType\": memberSet[i].tag,\n            \"type\": maritalStatus\n          });\n        } else {\n          // Filter pedigree info\n          function getPedigree(personID, parentType, relInfo) {\n            // GRAMPS\n            let person = peopleNodes.filter(hasID(personID));\n            let personFamily = person[0].families.filter(hasID(family.pointer));\n\n            if (parentType == 'HUSB') {\n              if (personFamily[0].pedi) {\n                return personFamily[0].pedi.frel;\n              } else if (relInfo.some(parent => parent.tag === \"_FREL\")) {\n                return relInfo.find(parent => parent.tag === \"_FREL\").data;\n              }\n            } else {\n              if (personFamily[0].pedi) {\n                return personFamily[0].pedi.mrel;\n              } else if (relInfo.some(parent => parent.tag === \"_MREL\")) {\n                return relInfo.find(parent => parent.tag === \"_MREL\").data;\n              }\n            }\n          }\n\n          memberLinks.push({\n            \"source\": memberSet[0].data,\n            \"target\": memberSet[i].data,\n            \"sourceType\": memberSet[0].tag,\n            \"targetType\": memberSet[i].tag,\n            \"type\": getPedigree(memberSet[i].data, memberSet[0].tag, memberSet[i].tree)\n          });\n        }\n      }\n    }\n\n    memberSet.splice(0, 1);\n  }\n\n  return memberLinks;\n};\n\nmodule.exports = d3ize;","map":{"version":3,"sources":["C:/Users/lianne/mygit/family_acestry_folder/familyancestry-wBloodlines/node_modules/gedcom-d3/d3ize.js"],"names":["d3ize","tree","notes","filter","hasTag","surnameList","peopleNodes","map","p","toNode","families","links","reduce","memo","family","concat","familyLinks","assignFy","nodes","val","node","tag","hasData","data","hasID","id","yesyob","yob","isNaN","forEach","fy","noyob","count","length","tempnoyob","slice","index","tpFamily","link","source","push","pRole","pType","sourceType","other","target","oType","targetType","member","person","undefined","splice","convertFy","fyRatio","allFy","total","average","getTitle","title","getName","nameNode","replace","getFirstName","firstNameNode","search","getSurname","surnameNode","nameArr","split","isSlashes","some","str","find","getGender","genderNode","getDOB","dobNode","dateNode","getYOB","getPOB","pobNode","placeNode","getDOD","dodNode","getYOD","thisYear","Date","getFullYear","getPOD","podNode","getFamilies","pediInfo","familyNode1","i","frel","mrel","pedi","familyNode2","getColor","colorList","dscr","foundName","sName","surname","color","getNotes","getBio","bio","personNote","note","pointer","fragment","getFy","name","firstName","gender","dob","pob","dod","yod","pod","memberLinks","maritalStatus","pedigree","memberSet","event","getPedigree","personID","parentType","relInfo","personFamily","parent","module","exports"],"mappings":"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","sourcesContent":["const d3ize = tree => {\n  const notes = tree.filter(hasTag('NOTE'));\n  let surnameList = []\n  const peopleNodes = tree\n    .filter(hasTag('INDI'))\n    .map(p => ( toNode(p, notes, surnameList )));\n  const families = tree.filter(hasTag('FAM'));\n  const links = families.reduce((memo, family) => {\n    return memo.concat(familyLinks(family, peopleNodes));\n  }, []);\n  assignFy(peopleNodes, links);\n  return {\n    nodes: peopleNodes,\n    links: links,\n    families: families,\n    surnameList: surnameList\n  };\n}\n\n// Tag search function\nconst hasTag = val => {\n  return node => {\n    return node.tag === val;\n  };\n}\n\n// Data search function\nconst hasData = val => {\n  return node => {\n    return node.data === val;\n  };\n}\n\n// ID search function\nconst hasID = val => {\n  return node => {\n    return node.id === val;\n  };\n}\n\nconst assignFy = (peopleNodes, links) => {\n\n  // YOB known\n  let yesyob = peopleNodes.filter(p => {\n    return p.yob !== '?' && !isNaN(+p.yob);\n  })\n\n  yesyob.forEach(p => p.fy = +(p.yob));\n\n  // YOB unknown\n  let noyob = peopleNodes.filter(p => {\n    return p.yob === '?';\n  });\n\n  let count = 10;\n\n  // Cycle through list, adding fy until all complete\n  while (noyob.length > 0 && count > 0) {\n\n    let tempnoyob = noyob.slice();\n\n    tempnoyob.forEach((p, index) => {\n\n      // Build array of family\n      let tpFamily = [];\n\n      links.forEach(link => {\n        if (link.source == p.id) {\n          tpFamily.push({pRole: 'source', pType: link.sourceType, other: link.target, oType: link.targetType});\n        } else if (link.target == p.id) {\n          tpFamily.push({pRole: 'target', pType: link.targetType, other: link.source, oType: link.sourceType});\n        };\n      });\n\n      // Check family for YOB\n      tpFamily.forEach(member => { // USE SOME() INSTEAD OF FOREACH!!!\n        peopleNodes.forEach(person => { // USE SOME() INSTEAD OF FOREACH!!!\n          if (person.id == member.other && person.fy !== undefined) {\n\n            // Person is source\n            if (member.pRole === 'source') {\n\n              // Person is husband\n              if (member.pType === 'HUSB' && member.oType === 'WIFE') {\n                p.fy = +person.fy - 3;\n\n              // Person is father\n              } else if (member.pType === 'HUSB' && member.oType === 'CHIL') {\n                p.fy = +person.fy - 30;\n\n              // Person is mother\n              } else if (member.pType === 'WIFE') {\n                p.fy = +person.fy - 27;\n              }\n\n              // Person is target\n            } else if (member.pRole === 'target') {\n\n              // Person is wife\n              if (member.pType === 'WIFE' && member.oType === 'HUSB') {\n                p.fy = +person.fy + 3;\n\n              // Person is child of father\n              } else if (member.pType === 'CHIL' && member.oType === 'HUSB') {\n                p.fy = +person.fy + 30;\n\n                // Person is child of mother\n              } else if (member.pType === 'CHIL' && member.oType === 'WIFE') {\n                p.fy = +person.fy + 27;\n              }\n            }\n          }\n        });\n      });\n      if (p.fy !== undefined) {\n        noyob.splice(index,index +1);\n      }\n    })\n    count -= 1;\n  }\n\n  const convertFy = (peopleNodes) => {\n    const fyRatio = peopleNodes => {\n      if (peopleNodes.length <= 50) {\n        return 3;\n      } else if (peopleNodes.length > 50 && peopleNodes.length <= 150) {\n        return 4;\n      } else if (peopleNodes.length > 150 && peopleNodes.length <= 250) {\n        return 5;\n      } else if (peopleNodes.length > 250){\n        return 6;\n      }\n    };\n    let allFy = [];\n    peopleNodes.forEach(p => {\n      if (p.fy !== undefined) {\n        p.fy = p.fy * fyRatio(peopleNodes);\n        allFy.push(p.fy);\n      }\n    })\n\n    let total = 0;\n    allFy.forEach(fy => total += fy);\n    let average = total/allFy.length;\n\n    peopleNodes.forEach(p => {\n      if (p.fy !== undefined) {\n        p.fy = -(p.fy - average);\n      }\n    });\n  }\n  convertFy(peopleNodes);\n}\n\n// Get title\nconst getTitle = p => {\n  const title = (p.tree.filter(hasTag('TITL')) || []);\n  if (title.length > 0) {\n    return title[title.length -1].data;\n  }\n}\n\n// Get full name\nconst getName = p => {\n  let nameNode = (p.tree.filter(hasTag('NAME')) || [])[0];\n  if (nameNode) {\n    return nameNode.data.replace(/\\//g, '');\n  } else {\n    return '?';\n  }\n}\n\n// Get first name\nconst getFirstName = p => {\n\n  // Find 'NAME' tag\n  const nameNode = (p.tree.filter(hasTag('NAME')) || [])[0];\n  if (nameNode) {\n\n    // Find 'GIVN' tag\n    let firstNameNode = (nameNode.tree.filter(hasTag('GIVN')) || [])[0];\n    if (firstNameNode) {\n\n      // Remove middle name\n      if (firstNameNode.data.search(' ') !== -1) {\n        return firstNameNode.data.slice(0, firstNameNode.data.search(' '));\n      } else {\n        return firstNameNode.data;\n      }\n    } else {\n      return '?';\n    }\n  } else {\n    return '?';\n  }\n}\n\n// Get surname\nconst getSurname = p => {\n\n  // Find 'NAME' tag\n  const nameNode = (p.tree.filter(hasTag('NAME')) || [])[0];\n  if (nameNode) {\n\n    // Find 'SURN' tag\n    const surnameNode = (nameNode.tree.filter(hasTag('SURN')) || [])[0];\n\n    // If surname listed\n    if (surnameNode) {\n\n      // Remove alternate surnames\n      if (surnameNode.data.search(',') !== -1) {\n        return surnameNode.data.slice(0, surnameNode.data.search(','));\n      } else {\n        return surnameNode.data;\n      }\n\n    // Derive surname from name\n    } else {\n      nameArr = nameNode.data.split(' ');\n\n      // Look for forward slashes\n      let isSlashes = nameArr.some(str => str[0] === \"/\");\n      if (isSlashes) {\n        return nameArr.find(str => str[0] === \"/\").replace(/\\//g, '');\n\n      // no slashes, use final item in array\n      } else {\n        nameArr[nameArr.length -1] = nameArr[nameArr.length -1].replace(/\\//g, '')\n        return nameArr.length > 1 ? nameArr[nameArr.length -1] : \"Hrm\"\n      }\n    }\n  } else {\n    return '?';\n  }\n}\n\n// Get gender\nconst getGender = p => {\n\n  // Find 'SEX' tag\n  let genderNode = (p.tree.filter(hasTag('SEX')) || [])[0];\n  if (genderNode) {\n    return genderNode.data;\n  } else {\n    return 'Unknown';\n  }\n}\n\n// Get date of birth\nconst getDOB = p => {\n\n  // Find 'BIRT' tag\n  let dobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n  if (dobNode) {\n\n    // Find 'DATE' tag\n    let dateNode = (dobNode.tree.filter(hasTag('DATE')) || [])[0];\n    if (dateNode) {\n      return dateNode.data;\n    } else {\n      return '?';\n    }\n  } else {\n    return '?';\n  }\n}\n\n// Get year of birth\nconst getYOB = p => {\n\n  // Find 'BIRT' tag\n  let dobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n  if (dobNode) {\n\n    // Find 'DATE' tag\n    let dateNode = (dobNode.tree.filter(hasTag('DATE')) || [])[0];\n    if (dateNode) {\n      return dateNode.data.slice(-4);\n    } else {\n      return '?';\n    }\n  } else {\n    return '?';\n  }\n}\n\n// Get place of birth\nconst getPOB = p => {\n\n  // Find 'BIRT' tag\n  let pobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n  if (pobNode) {\n\n    // Find 'DATE' tag\n    let placeNode = (pobNode.tree.filter(hasTag('PLAC')) || [])[0];\n    if (placeNode) {\n      return placeNode.data;\n    } else {\n      return '';\n    }\n  } else {\n    return '';\n  }\n}\n\n// Get date of death\nconst getDOD = p => {\n\n  // Find 'DEAT' tag\n  let dobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n  let dodNode = (p.tree.filter(hasTag('DEAT')) || [])[0];\n  if (dodNode) {\n\n    // Find 'DATE' tag\n    let dateNode = (dodNode.tree.filter(hasTag('DATE')) || [])[0];\n    if (dateNode) {\n      return dateNode.data;\n    } else {\n      return '?';\n    }\n  } else if (dobNode) {\n    let dateNode = (dobNode.tree.filter(hasTag('DATE')) || [])[0];\n    if (dateNode) {\n      return dateNode.data.slice(-4) + 100;\n    } else {\n      return '?';\n    }\n  } else {\n    return 'Present';\n  }\n}\n\n// Get year of death\nconst getYOD = p => {\n  let thisYear = new Date().getFullYear();\n\n  // Find 'DEAT' tag\n  let dobNode = (p.tree.filter(hasTag('BIRT')) || [])[0];\n  let dodNode = (p.tree.filter(hasTag('DEAT')) || [])[0];\n\n  // If DEATH tag\n  if (dodNode) {\n\n    // Find 'DATE' tag\n    let dateNode = (dodNode.tree.filter(hasTag('DATE')) || [])[0];\n\n    // If death date listed\n    if (dateNode) {\n      return dateNode.data.slice(-4);\n    } else {\n      return '?';\n    }\n\n  // BIRT tag, but no DEAT tag\n  } else if (dobNode && !dodNode) {\n    let dateNode = (dobNode.tree.filter(hasTag('DATE')) || [])[0];\n\n    // If DOB listed\n    if (dateNode) {\n\n      // If born > 100 yrs ago, call dead\n      if (dateNode.data.slice(-4) < (thisYear - 100)) {\n        return '?';\n      } else {\n        return 'Present';\n      }\n    } else {\n      return '?';\n    }\n\n  // no DEAT or BIRT tag\n  } else {\n    return '?';\n  }\n}\n\n// Get place of birth\nconst getPOD = p => {\n\n  // Find 'BIRT' tag\n  let podNode = (p.tree.filter(hasTag('DEAT')) || [])[0];\n  if (podNode) {\n\n    // Find 'DATE' tag\n    let placeNode = (podNode.tree.filter(hasTag('PLAC')) || [])[0];\n    if (placeNode) {\n      return placeNode.data;\n    } else {\n      return '';\n    }\n  } else {\n    return '';\n  }\n}\n\n// Get relatives\nconst getFamilies = p => {\n  let families = [];\n  let pediInfo;\n  // If child\n  let familyNode1 = (p.tree.filter(hasTag('FAMC')) || []);\n  if (familyNode1) {\n    for (let i = 0; i < familyNode1.length; i++) {\n      if (familyNode1[i].tree.length > 0) {\n        // Get pedigree info\n        if (familyNode1[i].tree[0].tag == 'PEDI') {\n          pediInfo = {frel: familyNode1[i].tree[0].data, mrel: familyNode1[i].tree[0].data}\n        } else if (familyNode1[i].tree[0].tag == '_FREL') {\n          pediInfo = {frel: familyNode1[i].tree[0].data, mrel: familyNode1[i].tree[1].data}\n        }\n      }\n\n      families.push({id: familyNode1[i].data, pedi: pediInfo});\n    }\n  }\n  let familyNode2 = (p.tree.filter(hasTag('FAMS')) || []);\n  if (familyNode2) {\n    for (let i = 0; i < familyNode2.length; i++) {\n      families.push({id:familyNode2[i].data});\n    }\n  }\n  return families;\n}\n\n// Get color\nconst getColor = (p, surnameList) => {\n  const colorList = [\n    '#ff7f50', // coral\n    '#00b4ff', // sky blue\n    '#fac641', // mexican egg yolk\n    '#8a9b0f', // olive\n    '#a7dbd8', // sea foam\n    '#a37e58', // light brown\n    '#ec4913', // burnt orange\n    '#a27dbd', // soft royal purple\n    '#11644d', // forest\n    '#b3347c', // magenta\n    '#359668', // grass & sage\n    '#fab8b4', // soft pink\n    '#6de627', // neon green\n    '#ecd078', // tangerine\n    '#bfcff7', // ligt purple blue\n    '#e08e79', // blush\n    '#c44d58', // rouge\n    '#c4ffeb', // light sea foam\n    '#a6b890', // olive sage\n    '#aaaaaa', // light blue grey\n    '#ffd3b5', // peach\n    '#826942', // chocolate\n    '#d4ee5e', // lime\n    '#ecfc85', // light yellow\n    '#666666', // off white\n    '#ffa1c3', // newborn pink\n    '#6541a3', // royal purple\n    '#75616b', // dry wine\n    '#71cfde', // baby foam\n    '#e0e0e0', // light grey\n  ];\n\n  // If color description listed in GEDCOM\n  const dscr = (p.tree.filter(hasTag('DSCR')) || [])[0];\n\n  const foundName = surnameList.find(sName => sName.surname === p.surname);\n\n  // If surname already in list\n  if (foundName) {\n    foundName.count = foundName.count +1;\n  } else {\n    surnameList.push({\n      surname: p.surname,\n      count: 1,\n      color: colorList[surnameList.length % colorList.length]\n    })\n  }\n\n  // surnameList.color = surnameList.length % colorList.length});\n\n  // If color listed assign that\n  if (dscr) {\n    return dscr.data;\n\n  // else assign color from colorList\n  } else {\n    return surnameList.find(sName => sName.surname === p.surname).color;\n  }\n}\n\n// Get person notes\nconst getNotes = p => {\n  return p.tree.filter(hasTag('NOTE'));\n}\n\n// Get Bio\nconst getBio = (p, notes) => {\n\n  if (p.notes.length != 0) {\n    let bio = '';\n\n    // Notes for person\n    p.notes.forEach(personNote => {\n\n      // personNote.data points to NOTE object\n      if (notes.length > 0) {\n        notes.forEach(note => {\n          if (personNote.data === note.pointer) {\n            bio += note.data;\n\n            // Concat broken up note\n            if (note.tree.length > 0) { note.tree.forEach(fragment => bio += fragment.data) }\n\n          }\n        });\n\n      // personNote.data is actual note\n      } else {\n        bio += personNote.data;\n      }\n    });\n    return bio;\n  }\n}\n\nconst getFy = p => {\n  if(p.yob === '?') {\n    return 0;\n  } else {\n    return +(-p.yob * 3 + 6000);\n  }\n}\n\nconst toNode = (p, notes, surnameList) => {\n  p.id = p.pointer;\n  p.title = getTitle(p);\n  p.name = getName(p);\n  p.firstName = getFirstName(p);\n  p.surname = getSurname(p);\n  p.gender = getGender(p);\n  p.dob = getDOB(p);\n  p.yob = getYOB(p);\n  p.pob = getPOB(p);\n  p.dod = getDOD(p);\n  p.yod = getYOD(p);\n  p.pod = getPOD(p);\n  p.families = getFamilies(p);\n  p.color = getColor(p, surnameList);\n  p.notes = getNotes(p);\n  p.bio = getBio(p, notes);\n  return p;\n}\n\nconst familyLinks = (family, peopleNodes) => {\n\n  let memberLinks = [];\n  let maritalStatus = null;\n  let pedigree;\n\n  // Filter only individual objects from family tree\n  let memberSet = family.tree.filter(function(member) {\n    return member.data && (member.data[1] === 'I' || member.data[1] === 'P');\n  })\n\n  // Filter marital status events\n  family.tree.filter(event => {\n    if (event.tag === 'DIV' || event.tag === 'MARR') {\n      if (maritalStatus !== 'DIV') {\n        maritalStatus = event.tag;\n      }\n    }\n  })\n\n  // Iterate over each member of set to connect with other members\n  while (memberSet.length > 1) {\n    for (let i = 1; i < memberSet.length; i++) {\n\n      // Exclude sibling relationships\n      if (memberSet[0].tag != 'CHIL') {\n\n        // If marital status listed\n        if (memberSet[0].tag == 'HUSB' && memberSet[i].tag == 'WIFE') {\n          memberLinks.push({\n            \"source\": memberSet[0].data,\n            \"target\": memberSet[i].data,\n            \"sourceType\": memberSet[0].tag,\n            \"targetType\": memberSet[i].tag,\n            \"type\": maritalStatus\n          })\n        } else {\n\n          // Filter pedigree info\n          function getPedigree(personID, parentType, relInfo) {\n            // GRAMPS\n            let person = peopleNodes.filter(hasID(personID));\n            let personFamily = person[0].families.filter(hasID(family.pointer));\n            if (parentType == 'HUSB') {\n              if (personFamily[0].pedi) {\n                return personFamily[0].pedi.frel;\n              } else if (relInfo.some(parent => parent.tag === \"_FREL\")) {\n                return relInfo.find(parent => parent.tag === \"_FREL\").data;\n              }\n            } else {\n              if (personFamily[0].pedi) {\n                return personFamily[0].pedi.mrel;\n              } else if (relInfo.some(parent => parent.tag === \"_MREL\")) {\n                return relInfo.find(parent => parent.tag === \"_MREL\").data;\n              }\n            }\n          }\n\n          memberLinks.push({\n            \"source\": memberSet[0].data,\n            \"target\": memberSet[i].data,\n            \"sourceType\": memberSet[0].tag,\n            \"targetType\": memberSet[i].tag,\n            \"type\": getPedigree(memberSet[i].data, memberSet[0].tag, memberSet[i].tree)\n          })\n        }\n      }\n    }\n    memberSet.splice(0,1);\n  }\n  return memberLinks;\n}\n\nmodule.exports = d3ize;\n"]},"metadata":{},"sourceType":"script"}