{"ast":null,"code":"var crawl = require('tree-crawl'); // from https://github.com/madprime/python-gedcom/blob/master/gedcom/__init__.py\n// * Level must start with nonnegative int, no leading zeros.\n// * Pointer optional, if it exists it must be flanked by '@'\n// * Tag must be alphanumeric string\n// * Value optional, consists of anything after a space to end of line\n//   End of line defined by \\n or \\r\n\n\nvar lineRe = /\\s*(0|[1-9]+[0-9]*) (@[^@]+@ |)([A-Za-z0-9_]+)( [^\\n\\r]*|)/;\n\nfunction parse(input) {\n  var start = {\n    root: {\n      tree: []\n    },\n    level: 0\n  };\n  start.pointer = start.root;\n  var data = input.split('\\n').map(mapLine).filter(function (_) {\n    return _;\n  }).reduce(buildTree, start).root;\n  crawl(data, cleanUp, {\n    getChildren\n  }); //console.log(data);\n  //var cleanTree = data.tree.filter(hasTag('INDI'));\n  //console.log(cleanTree);\n\n  return data.tree; // the basic trick of this module is turning the suggested tree\n  // structure of a GEDCOM file into a tree in JSON. This reduction\n  // does that. The only real trick is the `.up` member of objects\n  // that points to a level up in the structure. This we have to\n  // censor before JSON.stringify since it creates circular references.\n\n  function buildTree(memo, data) {\n    if (data.level === memo.level) {\n      memo.pointer.tree.push(data);\n    } else if (data.level > memo.level) {\n      var up = memo.pointer;\n      memo.pointer = memo.pointer.tree[memo.pointer.tree.length - 1];\n      memo.pointer.tree.push(data);\n      memo.pointer.up = up;\n      memo.level = data.level;\n    } else if (data.level < memo.level) {\n      // the jump up in the stack may be by more than one, so ascend\n      // until we're at the right level.\n      while (data.level <= memo.pointer.level && memo.pointer.up) {\n        memo.pointer = memo.pointer.up;\n      }\n\n      memo.pointer.tree.push(data);\n      memo.level = data.level;\n    }\n\n    return memo;\n  }\n\n  function mapLine(data) {\n    var match = data.match(lineRe);\n    if (!match) return null;\n    return {\n      level: parseInt(match[1], 10),\n      pointer: match[2].trim(),\n      tag: match[3].trim(),\n      data: match[4].trimLeft(),\n      tree: []\n    };\n  }\n\n  function cleanUp(node) {\n    delete node.up;\n    delete node.level;\n  }\n\n  function getChildren(node) {\n    //console.log(node.tree);\n    return node.tree;\n  }\n}\n\nmodule.exports.parse = parse;\nmodule.exports.d3ize = require('./d3ize');","map":{"version":3,"sources":["C:/Users/lianne/mygit/family_acestry_folder/familyancestry-wBloodlines/node_modules/gedcom-d3/index.js"],"names":["crawl","require","lineRe","parse","input","start","root","tree","level","pointer","data","split","map","mapLine","filter","_","reduce","buildTree","cleanUp","getChildren","memo","push","up","length","match","parseInt","trim","tag","trimLeft","node","module","exports","d3ize"],"mappings":"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","sourcesContent":["var crawl = require('tree-crawl');\n\n// from https://github.com/madprime/python-gedcom/blob/master/gedcom/__init__.py\n// * Level must start with nonnegative int, no leading zeros.\n// * Pointer optional, if it exists it must be flanked by '@'\n// * Tag must be alphanumeric string\n// * Value optional, consists of anything after a space to end of line\n//   End of line defined by \\n or \\r\nvar lineRe = /\\s*(0|[1-9]+[0-9]*) (@[^@]+@ |)([A-Za-z0-9_]+)( [^\\n\\r]*|)/;\n\nfunction parse(input) {\n\n    var start = { root: { tree: [] }, level: 0 };\n    start.pointer = start.root;\n\n    var data = input\n        .split('\\n')\n        .map(mapLine)\n        .filter(function(_) { return _; })\n        .reduce(buildTree, start)\n        .root;\n\n    crawl(data, cleanUp, { getChildren });\n    //console.log(data);\n    //var cleanTree = data.tree.filter(hasTag('INDI'));\n    //console.log(cleanTree);\n    return data.tree;\n\n    // the basic trick of this module is turning the suggested tree\n    // structure of a GEDCOM file into a tree in JSON. This reduction\n    // does that. The only real trick is the `.up` member of objects\n    // that points to a level up in the structure. This we have to\n    // censor before JSON.stringify since it creates circular references.\n    function buildTree(memo, data) {\n        if (data.level === memo.level) {\n            memo.pointer.tree.push(data);\n        } else if (data.level > memo.level) {\n            var up = memo.pointer;\n            memo.pointer = memo.pointer.tree[\n                memo.pointer.tree.length - 1];\n                memo.pointer.tree.push(data);\n                memo.pointer.up = up;\n                memo.level = data.level;\n        } else if (data.level < memo.level) {\n            // the jump up in the stack may be by more than one, so ascend\n            // until we're at the right level.\n            while (data.level <= memo.pointer.level && memo.pointer.up) {\n                memo.pointer = memo.pointer.up;\n            }\n            memo.pointer.tree.push(data);\n            memo.level = data.level;\n        }\n\n        return memo;\n    }\n\n    function mapLine(data) {\n        var match = data.match(lineRe);\n        if (!match) return null;\n        return {\n            level: parseInt(match[1], 10),\n            pointer: match[2].trim(),\n            tag: match[3].trim(),\n            data: match[4].trimLeft(),\n            tree: []\n        };\n    }\n\n    function cleanUp(node) {\n        delete node.up;\n        delete node.level;\n    }\n\n    function getChildren(node) {\n        //console.log(node.tree);\n        return node.tree;\n    }\n}\n\nmodule.exports.parse = parse;\nmodule.exports.d3ize = require('./d3ize');\n"]},"metadata":{},"sourceType":"script"}