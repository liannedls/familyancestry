{"ast":null,"code":"import { prop, withId, withType, flat, inAscOrder, min, max } from '../utils';\nexport default (families => {\n  const connectors = [];\n  families.filter(withType('root', 'child')).forEach(family => {\n    if (family.pUnits.length !== 1) {\n      throw new Error(\"[relatives-tree]: a child family should have only one parent's unit\");\n    }\n\n    const mY = family.top + 2;\n    const pUnit = family.pUnits[0];\n    const pX = family.left + pUnit.shift + pUnit.size;\n    const pY = family.top + 1;\n    connectors.push({\n      points: [pX, pY, pX, mY]\n    });\n    const parentIds = family.pUnits.map(prop('ids')).reduce(flat);\n    const cXs = [];\n    family.cUnits.forEach(cUnit => {\n      const cX = family.left + cUnit.shift + 1;\n      cUnit.nodes.forEach((node, index) => {\n        if (node.parents.find(rel => parentIds.indexOf(rel.id) !== -1)) {\n          const nX = cX + index * 2;\n          cXs.push(nX);\n          connectors.push({\n            points: [nX, mY, nX, mY + 1]\n          });\n        }\n      });\n\n      if (cUnit.size === 2) {\n        connectors.push({\n          points: [cX, mY + 1, cX + 2, mY + 1]\n        });\n      } else if (cUnit.size === 1 && cUnit.nodes[0].spouses.length) {\n        family.cUnits.forEach(nUnit => {\n          if (nUnit.nodes.findIndex(withId(cUnit.nodes[0].spouses[0].id)) !== -1) {\n            const xX = [cX, family.left + nUnit.shift + 1].sort(inAscOrder);\n            connectors.push({\n              points: [xX[0], mY + 1, xX[1], mY + 1]\n            });\n          }\n        });\n      }\n    });\n\n    if (cXs.length > 1) {\n      connectors.push({\n        points: [min(cXs), mY, max(cXs), mY]\n      });\n    } else if (cXs.length === 1 && pX !== cXs[0]) {\n      connectors.push({\n        points: [Math.min(pX, cXs[0]), mY, Math.max(pX, cXs[0]), mY]\n      });\n    }\n  });\n  return connectors;\n});","map":null,"metadata":{},"sourceType":"module"}